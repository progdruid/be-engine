
/*

@be-material: Object
[
    "Model: matrix",
    "ProjectionView: matrix",
    "ViewerPosition: float3 = [0, 0, 0]",
]
@be-end

@be-material: Main
[
    "DiffuseColor: float3 = [1.0, 1.0, 1.0]",
    "SpecularColor: float3 = [1.0, 1.0, 1.0]",
    "Shininess: float = 0.0",

    "DiffuseTexture: texture2d(0) = white",
    "SpecularTexture: texture2d(1) = black",

    "InputSampler: sampler(0)",
]
@be-end


@be-shader:
{
    "topology": "triangle-list",
    "vertex": "VertexFunction",
    "vertexLayout": ["position", "normal", "uv0"],
    "pixel": "PixelFunction",
    "materials": {
        "Object": 1,
        "Main": 2,
    },
    "targets": {
        "Diffuse.RGB": 0,
        "WorldNormal.XYZ": 1,
        "Specular.RGB_Shininess.A": 2
    }
}
@be-end

*/

cbuffer ModelBuffer: register(b1) {
    row_major float4x4 _Model;
    row_major float4x4 _ProjectionView;
    float3 _ViewerPosition;
}

cbuffer MaterialBuffer: register(b2) {
    float3 _DiffuseColor;
    float3 _SpecularColor;
    float _Shininess;
};

SamplerState DefaultSampler : register(s0);
Texture2D DiffuseTexture : register(t0);
Texture2D Specular : register(t1);

struct VertexInput {
    float3 Position : POSITION;
    float3 Normal : NORMAL;
    float2 UV    : TEXCOORD0;
};

struct VertexOutput {
    float4 Position : SV_POSITION;
    float3 Normal : NORMAL;
    float2 UV    : TEXCOORD0;
};

struct PixelOutput {
    float3 DiffuseRGB : SV_Target0;
    float4 WorldNormalXYZ_UnusedA : SV_Target1;
    float4 SpecularRGB_ShininessA : SV_Target2;
};

VertexOutput VertexFunction(VertexInput input) {
    float4 worldPosition = mul(float4(input.Position, 1.0), _Model);
    
    VertexOutput output;
    output.Position = mul(worldPosition, _ProjectionView);
    output.Normal = normalize(mul(input.Normal, (float3x3)_Model));
    output.UV = input.UV;

    return output;
}

PixelOutput PixelFunction(VertexOutput input) {
    float4 diffuseColor = DiffuseTexture.Sample(DefaultSampler, input.UV);
    float4 specularColor = Specular.Sample(DefaultSampler, input.UV);
    if (diffuseColor.a < 0.5) discard;

    PixelOutput output;
    output.DiffuseRGB = diffuseColor.rgb * _DiffuseColor;
    output.WorldNormalXYZ_UnusedA.xyz = normalize(input.Normal);
    output.WorldNormalXYZ_UnusedA.w = 1.0;
    output.SpecularRGB_ShininessA.rgb = specularColor.rgb * _SpecularColor;
    output.SpecularRGB_ShininessA.a = _Shininess / 2048.0;
    
    return output;
};